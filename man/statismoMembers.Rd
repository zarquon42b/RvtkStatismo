% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/AllGeneric.r, R/ModelMembers.r,
%   R/ModelMembersPointer.r
\docType{methods}
\name{StatismoModelMembers}
\alias{StatismoModelMembers}
\alias{DrawMean}
\alias{DrawMeanAtPoint}
\alias{DrawSample}
\alias{DrawSampleVector}
\alias{DrawSampleAtPoint}
\alias{ComputeCoefficients}
\alias{ComputeCoefficientsForPointValues}
\alias{ComputeCoefficientsForPointValuesWithCovariance}
\alias{GetDomainPoints}
\alias{GetDomainSize}
\alias{EvaluateSampleAtPoint}
\alias{GetModelInfo}
\alias{GetPCScores}
\alias{DrawMean,pPCA-method}
\alias{DrawMeanAtPoint,pPCA,numeric-method}
\alias{DrawSample,pPCA-method}
\alias{DrawSampleVector,pPCA-method}
\alias{DrawSampleAtPoint,pPCA,numeric,numeric-method}
\alias{ComputeCoefficients,pPCA-method}
\alias{GetDomainPoints,pPCA-method}
\alias{GetDomainSize,pPCA-method}
\alias{ComputeCoefficientsForPointValues,pPCA,matrix,numeric,numeric-method}
\alias{ComputeCoefficientsForPointValues,pPCA,matrix,matrix,numeric-method}
\alias{ComputeCoefficientsForPointValues,pPCA,numeric,numeric,numeric-method}
\alias{ComputeCoefficientsForPointValuesWithCovariance,pPCA,matrix,numeric,numeric-method}
\alias{ComputeCoefficientsForPointValuesWithCovariance,pPCA,matrix,matrix,numeric-method}
\alias{ComputeCoefficientsForPointValuesWithCovariance,pPCA,numeric,numeric,numeric-method}
\alias{ComputeCoefficientsForPointValuesWithCovariance,pPCA,matrix,numeric,matrix-method}
\alias{ComputeCoefficientsForPointValuesWithCovariance,pPCA,matrix,matrix,matrix-method}
\alias{ComputeCoefficientsForPointValuesWithCovariance,pPCA,numeric,numeric,matrix-method}
\alias{EvaluateSampleAtPoint,pPCA,matrix,numeric-method}
\alias{EvaluateSampleAtPoint,pPCA,mesh3d,numeric-method}
\alias{GetModelInfo,pPCA-method}
\alias{GetPCScores,pPCA-method}
\alias{DrawMean,pPCA_pointer-method}
\alias{DrawMeanAtPoint,pPCA_pointer,numeric-method}
\alias{DrawSample,pPCA_pointer-method}
\alias{DrawSampleVector,pPCA_pointer-method}
\alias{DrawSampleAtPoint,pPCA_pointer,numeric,numeric-method}
\alias{ComputeCoefficients,pPCA_pointer-method}
\alias{GetDomainPoints,pPCA_pointer-method}
\alias{GetDomainSize,pPCA_pointer-method}
\alias{ComputeCoefficientsForPointValues,pPCA_pointer,matrix,numeric,numeric-method}
\alias{ComputeCoefficientsForPointValues,pPCA_pointer,matrix,matrix,numeric-method}
\alias{ComputeCoefficientsForPointValues,pPCA_pointer,numeric,numeric,numeric-method}
\alias{ComputeCoefficientsForPointValuesWithCovariance,pPCA_pointer,matrix,numeric,numeric-method}
\alias{ComputeCoefficientsForPointValuesWithCovariance,pPCA_pointer,matrix,matrix,numeric-method}
\alias{ComputeCoefficientsForPointValuesWithCovariance,pPCA_pointer,numeric,numeric,numeric-method}
\alias{ComputeCoefficientsForPointValuesWithCovariance,pPCA_pointer,matrix,numeric,matrix-method}
\alias{ComputeCoefficientsForPointValuesWithCovariance,pPCA_pointer,matrix,matrix,matrix-method}
\alias{ComputeCoefficientsForPointValuesWithCovariance,pPCA_pointer,numeric,numeric,matrix-method}
\alias{EvaluateSampleAtPoint,pPCA_pointer,matrix,numeric-method}
\alias{EvaluateSampleAtPoint,pPCA_pointer,mesh3d,numeric-method}
\title{Implementation/Emulation of the statismo StatisticalModel class.}
\usage{
DrawMean(model)

DrawMeanAtPoint(model, pt)

DrawSample(model, coefficients = NULL, addNoise = FALSE)

DrawSampleVector(model, coefficients, addNoise = FALSE)

DrawSampleAtPoint(model, coefficients, pt, addNoise = FALSE)

ComputeCoefficients(model, dataset)

ComputeCoefficientsForPointValues(model, sample, pt, ptNoise = 0)

ComputeCoefficientsForPointValuesWithCovariance(model, sample, pt,
  ptNoise = 0)

GetDomainPoints(model)

GetDomainSize(model)

EvaluateSampleAtPoint(model, sample, pt)

GetModelInfo(model)

GetPCScores(model, scaled = TRUE)

\S4method{DrawMean}{pPCA}(model)

\S4method{DrawMeanAtPoint}{pPCA,numeric}(model, pt)

\S4method{DrawSample}{pPCA}(model, coefficients = NULL,
  addNoise = FALSE)

\S4method{DrawSampleVector}{pPCA}(model, coefficients, addNoise = FALSE)

\S4method{DrawSampleAtPoint}{pPCA,numeric,numeric}(model, coefficients, pt,
  addNoise = FALSE)

\S4method{ComputeCoefficients}{pPCA}(model, dataset)

\S4method{GetDomainPoints}{pPCA}(model)

\S4method{GetDomainSize}{pPCA}(model)


  \S4method{ComputeCoefficientsForPointValues}{pPCA,matrix,numeric,numeric}(model,
  sample, pt, ptNoise = 0)


  \S4method{ComputeCoefficientsForPointValues}{pPCA,matrix,matrix,numeric}(model,
  sample, pt, ptNoise = 0)


  \S4method{ComputeCoefficientsForPointValues}{pPCA,numeric,numeric,numeric}(model,
  sample, pt, ptNoise = 0)


  \S4method{ComputeCoefficientsForPointValuesWithCovariance}{pPCA,matrix,numeric,numeric}(model,
  sample, pt, ptNoise = 0)


  \S4method{ComputeCoefficientsForPointValuesWithCovariance}{pPCA,matrix,matrix,numeric}(model,
  sample, pt, ptNoise = 0)


  \S4method{ComputeCoefficientsForPointValuesWithCovariance}{pPCA,numeric,numeric,numeric}(model,
  sample, pt, ptNoise = 0)


  \S4method{ComputeCoefficientsForPointValuesWithCovariance}{pPCA,matrix,numeric,matrix}(model,
  sample, pt, ptNoise = 0)


  \S4method{ComputeCoefficientsForPointValuesWithCovariance}{pPCA,matrix,matrix,matrix}(model,
  sample, pt, ptNoise = 0)


  \S4method{ComputeCoefficientsForPointValuesWithCovariance}{pPCA,numeric,numeric,matrix}(model,
  sample, pt, ptNoise = 0)

\S4method{EvaluateSampleAtPoint}{pPCA,matrix,numeric}(model, sample, pt)

\S4method{EvaluateSampleAtPoint}{pPCA,mesh3d,numeric}(model, sample, pt)

\S4method{GetModelInfo}{pPCA}(model)

\S4method{GetPCScores}{pPCA}(model, scaled = TRUE)

\S4method{DrawMean}{pPCA_pointer}(model)

\S4method{DrawMeanAtPoint}{pPCA_pointer,numeric}(model, pt)

\S4method{DrawSample}{pPCA_pointer}(model, coefficients = NULL,
  addNoise = FALSE)

\S4method{DrawSampleVector}{pPCA_pointer}(model, coefficients,
  addNoise = FALSE)

\S4method{DrawSampleAtPoint}{pPCA_pointer,numeric,numeric}(model,
  coefficients, pt, addNoise = FALSE)

\S4method{ComputeCoefficients}{pPCA_pointer}(model, dataset)

\S4method{GetDomainPoints}{pPCA_pointer}(model)

\S4method{GetDomainSize}{pPCA_pointer}(model)


  \S4method{ComputeCoefficientsForPointValues}{pPCA_pointer,matrix,numeric,numeric}(model,
  sample, pt, ptNoise = 0)


  \S4method{ComputeCoefficientsForPointValues}{pPCA_pointer,matrix,matrix,numeric}(model,
  sample, pt, ptNoise = 0)


  \S4method{ComputeCoefficientsForPointValues}{pPCA_pointer,numeric,numeric,numeric}(model,
  sample, pt, ptNoise = 0)


  \S4method{ComputeCoefficientsForPointValuesWithCovariance}{pPCA_pointer,matrix,numeric,numeric}(model,
  sample, pt, ptNoise = 0)


  \S4method{ComputeCoefficientsForPointValuesWithCovariance}{pPCA_pointer,matrix,matrix,numeric}(model,
  sample, pt, ptNoise = 0)


  \S4method{ComputeCoefficientsForPointValuesWithCovariance}{pPCA_pointer,numeric,numeric,numeric}(model,
  sample, pt, ptNoise = 0)


  \S4method{ComputeCoefficientsForPointValuesWithCovariance}{pPCA_pointer,matrix,numeric,matrix}(model,
  sample, pt, ptNoise = 0)


  \S4method{ComputeCoefficientsForPointValuesWithCovariance}{pPCA_pointer,matrix,matrix,matrix}(model,
  sample, pt, ptNoise = 0)


  \S4method{ComputeCoefficientsForPointValuesWithCovariance}{pPCA_pointer,numeric,numeric,matrix}(model,
  sample, pt, ptNoise = 0)

\S4method{EvaluateSampleAtPoint}{pPCA_pointer,matrix,numeric}(model,
  sample, pt)

\S4method{EvaluateSampleAtPoint}{pPCA_pointer,mesh3d,numeric}(model,
  sample, pt)
}
\arguments{
\item{model}{object of class \code{\link{pPCA}}}

\item{pt}{either an integer pointing to a coordinate or a 3D-vector containing the coordinates of the domain point of interest. For \code{ComputeCoefficientsForPointValues}, this can also specify a matrix of coordinates on the domain.}

\item{coefficients}{specify coefficients in the latent space to draw a sample}

\item{addNoise}{logical: if TRUE noise as specified in the model will be added to the returned sample}

\item{dataset}{an (already aligned) mesh or k x 3 matrix containing the datasets coordinates.}

\item{sample}{depending on the function a matrix, a numeric vector or a mesh3d (see methods below)}

\item{ptNoise}{specify the noise estimated in the points.}

\item{scaled}{logical: if TRUE, the scores are scaled by their standard deviation.}
}
\value{
\item{DrawMean}{Get the mean (either a matrix or a mesh3d)}
\item{GetMeanVector}{Get the mean vector}
\item{DrawMeanAtPoint}{Get a specific point of the  mean (numeric vector)}
\item{DrawSample}{Draw a sample from the model (either a matrix or a mesh3d)}
\item{DrawSampleAtPoint}{Draw a sample of a specific point from the model (numeric vector)  }
\item{ComputeCoefficients}{Computes the coefficients of the latent variables}
\item{ComputeCoefficientsForPointValues}{Returns the coefficients of the latent variables for the given values provided in two k x 3 matrices or two vectors of length 3, or one matrix/vector and a vector containing the indices on the domain  corresponding to these points}
 \item{ComputeCoefficientsForPointValuesWithCovariance}{Returns the coefficients of the latent variables for the given values provided in two k x 3 matrices or two vectors of length 3, or one matrix/vector and a vector containing the indices on the domain  corresponding to these points. In contrast to \code{ComputeCoefficientsForPointValues}, \code{ptNoise} can be set individually, either as vector of length \code{k} (assuming spherical noise) or a \eqn{(k*3) \times 3}{(k*3) x 3} matrix with the i-th \eqn{3 \times 3}{3x3} block containing the covariance matrix for the i-th coordinate.}
\item{GetDomainPoints}{a matrix containing the points of the model's domain}
\item{GetDomainSize}{get the size of the model's domain}
\item{EvaluateSampleAtPoint}{Returns the value of the given sample at the point specified (either as point on the domain or as an index)}
\item{GetPCScores}{get model's PC-scores, scaled or unscaled to unit variance, depending on the choice of \code{scaled}}
}
\description{
Implementation/Emulation of the statismo StatisticalModel class.
}
\details{
see \url{http://statismo.github.io/docs/api/v0.10/html/classstatismo_1_1StatisticalModel.html} for details.
}
\examples{
require(Morpho)
data(boneData)
align <- rigidAlign(boneLM)$rotated
mymod <- statismoBuildModel(align,representer=align[,,1],sigma=2,scale=TRUE)
mymean <- DrawMean(mymod)
mymeanvector <- GetMeanVector(mymod)
mymean1 <- DrawMeanAtPoint(mymod,1)
mysample <- DrawSample(mymod)
mysample1 <- DrawSampleAtPoint(mymod,coefficients=3,pt=1)
mycoeff <- ComputeCoefficients(mymod,align[,,1])
mycoeffpoint <- ComputeCoefficientsForPointValues(mymod,sample=align[1,,1],pt=1,ptNoise=0)
}
\keyword{StatisticalModel<representer>}
